---
const {
  quantity = 100, // Número de partículas
  color = '#1e293b', // Color base de las partículas (gris)
  size = 0.8, // Tamaño base de las partículas
  ease = 50, // Suavizado del movimiento hacia el mouse
  staticity = 50, // Intensidad del magnetismo
  vx = 0, // Velocidad horizontal global
  vy = 0, // Velocidad vertical global
} = Astro.props
---

<div class="absolute inset-0 pointer-events-none" aria-hidden="true">
  <canvas
    id="particles-canvas"
    data-quantity={quantity}
    data-color={color}
    data-size={size}
    data-ease={ease}
    data-staticity={staticity}
    data-vx={vx}
    data-vy={vy}
    class="absolute inset-0"></canvas>

  <script type="module">
    const canvas = document.getElementById('particles-canvas')
    const ctx = canvas.getContext('2d')
    const dpr = window.devicePixelRatio || 1

    // Si quieres pasar props desde Astro al canvas, setéalas como data-* en el markup.
    // Ejemplo en Astro: <canvas id="particles-canvas" data-quantity={quantity} ...></canvas>
    const quantityFromData = parseInt(canvas.dataset.quantity)
    const color = canvas.dataset.color || '#1e293b'
    const baseSize = parseFloat(canvas.dataset.size) || 0.8
    const ease = parseFloat(canvas.dataset.ease) || 50
    const staticity = parseFloat(canvas.dataset.staticity) || 50
    const vx = parseFloat(canvas.dataset.vx) || 0
    const vy = parseFloat(canvas.dataset.vy) || 0
    const quantity = Number.isFinite(quantityFromData) ? quantityFromData : 100

    let circles = []
    const mouse = { x: 0, y: 0 }
    const canvasSize = { w: 0, h: 0 }
    let rafId = null

    function hexToRgb(hex) {
      hex = String(hex).replace('#', '')
      if (hex.length === 3)
        hex = hex
          .split('')
          .map((c) => c + c)
          .join('')
      const int = parseInt(hex, 16)
      return [(int >> 16) & 255, (int >> 8) & 255, int & 255]
    }
    const rgb = hexToRgb(color)

    function getParentSize() {
      // usa bounding rect del padre, si es 0, cae a window.inner*
      const parent = canvas.parentElement
      if (!parent) return { w: window.innerWidth, h: window.innerHeight }
      const rect = parent.getBoundingClientRect()
      return {
        w: rect.width || window.innerWidth,
        h: rect.height || window.innerHeight,
      }
    }

    function setCanvasPixelSize(w, h) {
      canvas.width = Math.max(1, Math.floor(w * dpr))
      canvas.height = Math.max(1, Math.floor(h * dpr))
      canvas.style.width = w + 'px'
      canvas.style.height = h + 'px'
      // resetear transform y escalar para DPR
      ctx.setTransform(1, 0, 0, 1, 0, 0)
      ctx.scale(dpr, dpr)
    }

    function resizeCanvas() {
      const { w, h } = getParentSize()
      if (w === canvasSize.w && h === canvasSize.h) return
      canvasSize.w = w
      canvasSize.h = h
      setCanvasPixelSize(w, h)

      // repoblar partículas (no lo dejemos vacío)
      circles = []
      for (let i = 0; i < quantity; i++) circles.push(createCircle())
    }

    // debounce simple para resize
    let resizeTimeout = null
    function scheduleResize() {
      clearTimeout(resizeTimeout)
      resizeTimeout = setTimeout(resizeCanvas, 100)
    }
    window.addEventListener('resize', scheduleResize)
    window.addEventListener('orientationchange', scheduleResize)

    // mouse handler usa bounding rect en cada evento para mayor precisión
    window.addEventListener('mousemove', (e) => {
      const rect = canvas.getBoundingClientRect()
      // posición relativa al centro del canvas
      mouse.x = e.clientX - rect.left - canvasSize.w / 2
      mouse.y = e.clientY - rect.top - canvasSize.h / 2
    })

    function createCircle() {
      return {
        x: Math.random() * canvasSize.w,
        y: Math.random() * canvasSize.h,
        translateX: 0,
        translateY: 0,
        size: Math.random() * 2 + baseSize,
        alpha: 0,
        targetAlpha: Math.random() * 0.6 + 0.1,
        dx: (Math.random() - 0.5) * 0.1,
        dy: (Math.random() - 0.5) * 0.1,
        magnetism: 0.1 + Math.random() * 4,
      }
    }

    // preparar inicialmente el canvas y partículas
    resizeCanvas()

    // utility remap
    function remapValue(value, start1, end1, start2, end2) {
      const remap = ((value - start1) * (end2 - start2)) / (end1 - start1) + start2
      return remap > 0 ? remap : 0
    }

    function drawCircle(c) {
      // proteger contra canvas sin tamaño
      if (canvasSize.w === 0 || canvasSize.h === 0) return

      ctx.save()
      // aplicar translate por magnetismo (en coordenadas CSS, ya que ctx está escalado por dpr)
      ctx.translate(c.translateX, c.translateY)
      ctx.beginPath()
      ctx.arc(c.x, c.y, c.size, 0, Math.PI * 2)
      ctx.fillStyle = `rgba(${rgb.join(',')},${c.alpha})`
      ctx.fill()
      ctx.restore()
    }

    function animate() {
      // si el canvas tiene tamaño 0, no arrancar loop pesado
      if (canvasSize.w === 0 || canvasSize.h === 0) {
        rafId = requestAnimationFrame(animate)
        return
      }

      // limpiar con tamaño en CSS (ya escalado por ctx)
      ctx.clearRect(0, 0, canvasSize.w, canvasSize.h)

      for (let i = 0; i < circles.length; i++) {
        const c = circles[i]
        const edge = [
          c.x + c.translateX - c.size,
          canvasSize.w - c.x - c.translateX - c.size,
          c.y + c.translateY - c.size,
          canvasSize.h - c.y - c.translateY - c.size,
        ]
        const closestEdge = Math.min(...edge)
        const remap = remapValue(closestEdge, 0, 20, 0, 1)
        c.alpha = remap > 1 ? Math.min(c.alpha + 0.02, c.targetAlpha) : c.targetAlpha * remap

        c.x += c.dx + vx
        c.y += c.dy + vy

        c.translateX += (mouse.x / (staticity / c.magnetism) - c.translateX) / ease
        c.translateY += (mouse.y / (staticity / c.magnetism) - c.translateY) / ease

        if (
          c.x < -c.size ||
          c.x > canvasSize.w + c.size ||
          c.y < -c.size ||
          c.y > canvasSize.h + c.size
        ) {
          circles[i] = createCircle()
        }

        drawCircle(c)
      }

      rafId = requestAnimationFrame(animate)
    }

    // iniciar loop (aseguramos cancelar si ya había uno)
    if (rafId) cancelAnimationFrame(rafId)
    animate()

    // cleanup si este script se ejecuta en un entorno con montajes/desmontajes (p.e. frameworks)
    // opcional: no hace daño tenerlo
    window.addEventListener('beforeunload', () => {
      if (rafId) cancelAnimationFrame(rafId)
      window.removeEventListener('resize', scheduleResize)
      window.removeEventListener('orientationchange', scheduleResize)
    })
  </script>
</div>
